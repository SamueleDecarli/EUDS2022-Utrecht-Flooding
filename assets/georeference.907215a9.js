import{ae as C,m$ as j,jK as U,n0 as D,mr as V,n1 as W,n2 as O,e as p,d as g,n as H,eB as J,ah as z,iR as K,mC as X,n3 as Z,lN as Q,lE as P,dG as m,dD as L,n4 as h,f8 as _,n5 as k,e4 as nn,n6 as d,b8 as tn,n7 as rn,n8 as en,n9 as an,aO as on,r as v,k$ as sn,na as ln,kS as M,m0 as cn,nb as un,nc as q,t as f,nd as x,lA as y,ne as pn,nf as gn,bZ as fn,a9 as hn,jX as yn,lt as mn,ng as An,nh as $n,ni as dn,nj as xn,nk as wn,nl as Tn}from"./index.d1e29527.js";function A(n=vn){return[n[0],n[1],n[2],n[3]]}function Gn(n,r,t=A()){return C(t,n),t[3]=r,t}function In(n,r,t=A()){return j($,n,R(n)),j(B,r,R(r)),D($,B,$),Mn(t,V(W(t,$)))}function Sn(n){return n}function R(n){return U(n[3])}function Mn(n,r){return n[3]=r,n}const vn=[0,0,1,0],$=O(),B=O();A();var b;let u=b=class extends J{constructor(n){super(n),this.origin=z(),this.translation=z(),this.rotation=A(),this.scale=K(1,1,1),this.geographic=!0}get localMatrix(){const n=m();return X(n,this.scale),Z(n,n,R(this.rotation),this.rotation),Q(n,n,this.translation),n}get localMatrixInverse(){return P(m(),this.localMatrix)}applyLocal(n,r){return L(r,n,this.localMatrix)}applyLocalInverse(n,r){return L(r,n,this.localMatrixInverse)}project(n,r){const t=new Float64Array(n.length),e=h.fromTypedArray(t),a=h.fromTypedArray(n);if(this.geographic){const s=_(r),c=m();return k(r,this.origin,c,s),nn(c,c,this.localMatrix),d(e,a,c),tn(t,s,0,t,r,0,t.length/3),t}const{localMatrix:o,origin:i}=this;rn(o,en)?an(e,a):d(e,a,o);for(let s=0;s<t.length;s+=3)t[s+0]+=i[0],t[s+1]+=i[1],t[s+2]+=i[2];return t}getOriginPoint(n){const[r,t,e]=this.origin;return new on({x:r,y:t,z:e,spatialReference:n})}equals(n){return v(n)&&this.geographic===n.geographic&&sn(this.origin,n.origin)&&ln(this.localMatrix,n.localMatrix)}clone(){const n={origin:M(this.origin),translation:M(this.translation),rotation:A(this.rotation),scale:M(this.scale),geographic:this.geographic};return new b(n)}};p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"origin",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"translation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"rotation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"scale",void 0),p([g({type:Boolean,nonNullable:!0,json:{write:!0}})],u.prototype,"geographic",void 0),p([g()],u.prototype,"localMatrix",null),p([g()],u.prototype,"localMatrixInverse",null),u=b=p([H("esri.geometry.support.MeshTransform")],u);const Rn=u;function w(n,r){var t;return n.isGeographic||n.isWebMercator&&((t=r==null?void 0:r.geographic)!=null?t:!0)}function G(n,r,t){return w(r.spatialReference,t)?Nn(n,r,t):En(n,r,t)}function bn(n,r,t){const{position:e,normal:a,tangent:o}=n;if(f(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return G({position:xn(e,new Float64Array(e.length),i),normal:v(a)?wn(a,new Float32Array(a.length),i):null,tangent:v(o)?Tn(o,new Float32Array(o.length),i):null},r.getOriginPoint(t),{geographic:r.geographic})}function Yn(n,r,t){var e;if(t!=null&&t.useTransform){const{position:a,normal:o,tangent:i}=n;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new Rn({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:w(r.spatialReference,t)})}}return{vertexAttributes:G(n,r,t),transform:null}}function Fn(n,r,t){return w(r.spatialReference,t)?I(n,r,t):F(n,r,t)}function Cn(n,r,t,e){if(f(r))return Fn(n,t,e);const a=bn(n,r,t.spatialReference);return t.equals(r.getOriginPoint(t.spatialReference))?F(a,t,e):w(t.spatialReference,e)?I(a,t,e):F(a,t,e)}function En(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=N(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*T+s;return{position:e,normal:n.normal,tangent:n.tangent}}function Nn(n,r,t){const e=r.spatialReference,a=S(r,t,E),o=new Float64Array(n.position.length),i=jn(n.position,a,e,o),s=q(Y,a);return{position:i,normal:zn(i,o,n.normal,s,e),tangent:Ln(i,o,n.tangent,s,e)}}function jn(n,r,t,e){d(h.fromTypedArray(e),h.fromTypedArray(n),r);const a=new Float64Array(n.length);return un(e,a,t)}function zn(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);return x(y.fromTypedArray(o),y.fromTypedArray(t),e),pn(o,n,r,a,o),o}function Ln(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);x(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=t[i];return gn(o,n,r,a,o),o}function F(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=N(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/T;return{position:e,normal:n.normal,tangent:n.tangent}}function I(n,r,t){const e=r.spatialReference;S(r,t,E);const a=P(_n,E),o=new Float64Array(n.position.length),i=Bn(n.position,e,a,o),s=q(Y,a);return{position:i,normal:On(n.normal,n.position,o,e,s),tangent:Pn(n.tangent,n.position,o,e,s)}}function S(n,r,t){k(n.spatialReference,[n.x,n.y,n.z||0],t,_(n.spatialReference));const{horizontal:e,vertical:a}=N(r?r.unit:null,n.spatialReference);return cn(t,t,[e,e,a]),t}function Bn(n,r,t,e){const a=An(n,r,e),o=h.fromTypedArray(a),i=new Float64Array(a.length),s=h.fromTypedArray(i);return d(s,o,t),i}function On(n,r,t,e,a){if(f(n))return null;const o=$n(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o);return x(i,i,a),o}function Pn(n,r,t,e,a){if(f(n))return null;const o=dn(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return x(i,i,a),o}function N(n,r){if(f(n))return kn;const t=r.isGeographic?1:fn(r),e=r.isGeographic?1:hn(r),a=yn(1,n,"meters");return{horizontal:a*t,vertical:a*e}}const E=m(),_n=m(),Y=mn(),kn={horizontal:1,vertical:1};export{Rn as L,Fn as M,Cn as P,bn as _,A as a,R as b,Gn as c,In as g,Yn as k,Sn as l,w as r,G as x};
