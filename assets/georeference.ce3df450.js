import{ao as Y,n4 as j,jO as H,n5 as J,mw as U,n6 as W,n7 as O,g as p,i as g,n as C,eH as D,ar as z,iV as K,mH as Q,n8 as X,lS as Z,lJ as P,dM as m,dJ as L,n9 as h,fe as _,na as q,ea as nn,nb as d,bd as tn,nc as rn,nd as en,ne as an,aV as on,r as v,l3 as sn,nf as ln,kW as M,m5 as cn,ng as un,nh as k,t as f,ni as x,lF as y,nj as pn,nk as gn,c3 as fn,aj as hn,j$ as yn,ly as mn,nl as An,nm as $n,nn as dn,no as xn,np as wn,nq as Tn}from"./vendor.e1f4f720.js";function A(n=vn){return[n[0],n[1],n[2],n[3]]}function In(n,r,t=A()){return Y(t,n),t[3]=r,t}function Sn(n,r,t=A()){return j($,n,F(n)),j(B,r,F(r)),J($,B,$),Mn(t,U(W(t,$)))}function Gn(n){return n}function F(n){return H(n[3])}function Mn(n,r){return n[3]=r,n}const vn=[0,0,1,0],$=O(),B=O();A();var R;let u=R=class extends D{constructor(n){super(n),this.origin=z(),this.translation=z(),this.rotation=A(),this.scale=K(1,1,1),this.geographic=!0}get localMatrix(){const n=m();return Q(n,this.scale),X(n,n,F(this.rotation),this.rotation),Z(n,n,this.translation),n}get localMatrixInverse(){return P(m(),this.localMatrix)}applyLocal(n,r){return L(r,n,this.localMatrix)}applyLocalInverse(n,r){return L(r,n,this.localMatrixInverse)}project(n,r){const t=new Float64Array(n.length),e=h.fromTypedArray(t),a=h.fromTypedArray(n);if(this.geographic){const s=_(r),c=m();return q(r,this.origin,c,s),nn(c,c,this.localMatrix),d(e,a,c),tn(t,s,0,t,r,0,t.length/3),t}const{localMatrix:o,origin:i}=this;rn(o,en)?an(e,a):d(e,a,o);for(let s=0;s<t.length;s+=3)t[s+0]+=i[0],t[s+1]+=i[1],t[s+2]+=i[2];return t}getOriginPoint(n){const[r,t,e]=this.origin;return new on({x:r,y:t,z:e,spatialReference:n})}equals(n){return v(n)&&this.geographic===n.geographic&&sn(this.origin,n.origin)&&ln(this.localMatrix,n.localMatrix)}clone(){const n={origin:M(this.origin),translation:M(this.translation),rotation:A(this.rotation),scale:M(this.scale),geographic:this.geographic};return new R(n)}};p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"origin",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"translation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"rotation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"scale",void 0),p([g({type:Boolean,nonNullable:!0,json:{write:!0}})],u.prototype,"geographic",void 0),p([g()],u.prototype,"localMatrix",null),p([g()],u.prototype,"localMatrixInverse",null),u=R=p([C("esri.geometry.support.MeshTransform")],u);const Fn=u;function w(n,r){var t;return n.isGeographic||n.isWebMercator&&((t=r==null?void 0:r.geographic)!=null?t:!0)}function I(n,r,t){return w(r.spatialReference,t)?Nn(n,r,t):En(n,r,t)}function Rn(n,r,t){const{position:e,normal:a,tangent:o}=n;if(f(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return I({position:xn(e,new Float64Array(e.length),i),normal:v(a)?wn(a,new Float32Array(a.length),i):null,tangent:v(o)?Tn(o,new Float32Array(o.length),i):null},r.getOriginPoint(t),{geographic:r.geographic})}function Vn(n,r,t){var e;if(t==null?void 0:t.useTransform){const{position:a,normal:o,tangent:i}=n;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new Fn({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:w(r.spatialReference,t)})}}return{vertexAttributes:I(n,r,t),transform:null}}function bn(n,r,t){return w(r.spatialReference,t)?S(n,r,t):b(n,r,t)}function Yn(n,r,t,e){if(f(r))return bn(n,t,e);const a=Rn(n,r,t.spatialReference);return t.equals(r.getOriginPoint(t.spatialReference))?b(a,t,e):w(t.spatialReference,e)?S(a,t,e):b(a,t,e)}function En(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=N(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*T+s;return{position:e,normal:n.normal,tangent:n.tangent}}function Nn(n,r,t){const e=r.spatialReference,a=G(r,t,E),o=new Float64Array(n.position.length),i=jn(n.position,a,e,o),s=k(V,a);return{position:i,normal:zn(i,o,n.normal,s,e),tangent:Ln(i,o,n.tangent,s,e)}}function jn(n,r,t,e){d(h.fromTypedArray(e),h.fromTypedArray(n),r);const a=new Float64Array(n.length);return un(e,a,t)}function zn(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);return x(y.fromTypedArray(o),y.fromTypedArray(t),e),pn(o,n,r,a,o),o}function Ln(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);x(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=t[i];return gn(o,n,r,a,o),o}function b(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=N(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/T;return{position:e,normal:n.normal,tangent:n.tangent}}function S(n,r,t){const e=r.spatialReference;G(r,t,E);const a=P(_n,E),o=new Float64Array(n.position.length),i=Bn(n.position,e,a,o),s=k(V,a);return{position:i,normal:On(n.normal,n.position,o,e,s),tangent:Pn(n.tangent,n.position,o,e,s)}}function G(n,r,t){q(n.spatialReference,[n.x,n.y,n.z||0],t,_(n.spatialReference));const{horizontal:e,vertical:a}=N(r?r.unit:null,n.spatialReference);return cn(t,t,[e,e,a]),t}function Bn(n,r,t,e){const a=An(n,r,e),o=h.fromTypedArray(a),i=new Float64Array(a.length),s=h.fromTypedArray(i);return d(s,o,t),i}function On(n,r,t,e,a){if(f(n))return null;const o=$n(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o);return x(i,i,a),o}function Pn(n,r,t,e,a){if(f(n))return null;const o=dn(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return x(i,i,a),o}function N(n,r){if(f(n))return qn;const t=r.isGeographic?1:fn(r),e=r.isGeographic?1:hn(r),a=yn(1,n,"meters");return{horizontal:a*t,vertical:a*e}}const E=m(),_n=m(),V=mn(),qn={horizontal:1,vertical:1};export{Fn as L,bn as M,Yn as P,Rn as _,A as a,F as b,In as c,Sn as g,Vn as k,Gn as l,w as r,I as x};
