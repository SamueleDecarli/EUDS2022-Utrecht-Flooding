import{ao as U,nc as N,jW as W,nd as C,mE as V,ne as D,nf as _,i as p,j as g,n as H,eM as J,ar as z,j1 as K,mP as Q,ng as X,l_ as Z,lR as B,dR as m,dO as L,nh as h,fj as O,ni as q,ef as nn,nj as x,bi as tn,nk as rn,nl as en,nm as an,aY as on,r as v,lb as sn,nn as ln,l2 as M,md as cn,no as un,np as k,t as f,nq as d,lN as y,nr as pn,ns as gn,c8 as fn,aj as hn,k7 as yn,lG as mn,nt as An,nu as $n,nv as xn,nw as dn,nx as wn,ny as Tn}from"./vendor.5530b0a9.js";function A(n=vn){return[n[0],n[1],n[2],n[3]]}function Gn(n,r,t=A()){return U(t,n),t[3]=r,t}function In(n,r,t=A()){return N($,n,R(n)),N(P,r,R(r)),C($,P,$),Mn(t,V(D(t,$)))}function Yn(n){return n}function R(n){return W(n[3])}function Mn(n,r){return n[3]=r,n}const vn=[0,0,1,0],$=_(),P=_();A();var F;let u=F=class extends J{constructor(n){super(n),this.origin=z(),this.translation=z(),this.rotation=A(),this.scale=K(1,1,1),this.geographic=!0}get localMatrix(){const n=m();return Q(n,this.scale),X(n,n,R(this.rotation),this.rotation),Z(n,n,this.translation),n}get localMatrixInverse(){return B(m(),this.localMatrix)}applyLocal(n,r){return L(r,n,this.localMatrix)}applyLocalInverse(n,r){return L(r,n,this.localMatrixInverse)}project(n,r){const t=new Float64Array(n.length),e=h.fromTypedArray(t),a=h.fromTypedArray(n);if(this.geographic){const s=O(r),c=m();return q(r,this.origin,c,s),nn(c,c,this.localMatrix),x(e,a,c),tn(t,s,0,t,r,0,t.length/3),t}const{localMatrix:o,origin:i}=this;rn(o,en)?an(e,a):x(e,a,o);for(let s=0;s<t.length;s+=3)t[s+0]+=i[0],t[s+1]+=i[1],t[s+2]+=i[2];return t}getOriginPoint(n){const[r,t,e]=this.origin;return new on({x:r,y:t,z:e,spatialReference:n})}equals(n){return v(n)&&this.geographic===n.geographic&&sn(this.origin,n.origin)&&ln(this.localMatrix,n.localMatrix)}clone(){const n={origin:M(this.origin),translation:M(this.translation),rotation:A(this.rotation),scale:M(this.scale),geographic:this.geographic};return new F(n)}};p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"origin",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"translation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"rotation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"scale",void 0),p([g({type:Boolean,nonNullable:!0,json:{write:!0}})],u.prototype,"geographic",void 0),p([g()],u.prototype,"localMatrix",null),p([g()],u.prototype,"localMatrixInverse",null),u=F=p([H("esri.geometry.support.MeshTransform")],u);const Rn=u;function w(n,r){var t;return n.isGeographic||n.isWebMercator&&((t=r==null?void 0:r.geographic)!=null?t:!0)}function G(n,r,t){return w(r.spatialReference,t)?jn(n,r,t):En(n,r,t)}function Fn(n,r,t){const{position:e,normal:a,tangent:o}=n;if(f(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return G({position:dn(e,new Float64Array(e.length),i),normal:v(a)?wn(a,new Float32Array(a.length),i):null,tangent:v(o)?Tn(o,new Float32Array(o.length),i):null},r.getOriginPoint(t),{geographic:r.geographic})}function Sn(n,r,t){var e;if(t==null?void 0:t.useTransform){const{position:a,normal:o,tangent:i}=n;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new Rn({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:w(r.spatialReference,t)})}}return{vertexAttributes:G(n,r,t),transform:null}}function bn(n,r,t){return w(r.spatialReference,t)?I(n,r,t):b(n,r,t)}function Un(n,r,t,e){if(f(r))return bn(n,t,e);const a=Fn(n,r,t.spatialReference);return t.equals(r.getOriginPoint(t.spatialReference))?b(a,t,e):w(t.spatialReference,e)?I(a,t,e):b(a,t,e)}function En(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=j(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*T+s;return{position:e,normal:n.normal,tangent:n.tangent}}function jn(n,r,t){const e=r.spatialReference,a=Y(r,t,E),o=new Float64Array(n.position.length),i=Nn(n.position,a,e,o),s=k(S,a);return{position:i,normal:zn(i,o,n.normal,s,e),tangent:Ln(i,o,n.tangent,s,e)}}function Nn(n,r,t,e){x(h.fromTypedArray(e),h.fromTypedArray(n),r);const a=new Float64Array(n.length);return un(e,a,t)}function zn(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);return d(y.fromTypedArray(o),y.fromTypedArray(t),e),pn(o,n,r,a,o),o}function Ln(n,r,t,e,a){if(f(t))return null;const o=new Float32Array(t.length);d(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=t[i];return gn(o,n,r,a,o),o}function b(n,r,t){const e=new Float64Array(n.position.length),a=n.position,o=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:T}=j(t?t.unit:null,r.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/T;return{position:e,normal:n.normal,tangent:n.tangent}}function I(n,r,t){const e=r.spatialReference;Y(r,t,E);const a=B(On,E),o=new Float64Array(n.position.length),i=Pn(n.position,e,a,o),s=k(S,a);return{position:i,normal:_n(n.normal,n.position,o,e,s),tangent:Bn(n.tangent,n.position,o,e,s)}}function Y(n,r,t){q(n.spatialReference,[n.x,n.y,n.z||0],t,O(n.spatialReference));const{horizontal:e,vertical:a}=j(r?r.unit:null,n.spatialReference);return cn(t,t,[e,e,a]),t}function Pn(n,r,t,e){const a=An(n,r,e),o=h.fromTypedArray(a),i=new Float64Array(a.length),s=h.fromTypedArray(i);return x(s,o,t),i}function _n(n,r,t,e,a){if(f(n))return null;const o=$n(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o);return d(i,i,a),o}function Bn(n,r,t,e,a){if(f(n))return null;const o=xn(n,r,t,e,new Float32Array(n.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return d(i,i,a),o}function j(n,r){if(f(n))return qn;const t=r.isGeographic?1:fn(r),e=r.isGeographic?1:hn(r),a=yn(1,n,"meters");return{horizontal:a*t,vertical:a*e}}const E=m(),On=m(),S=mn(),qn={horizontal:1,vertical:1};export{Rn as L,bn as M,Un as P,Fn as _,A as a,R as b,Gn as c,In as g,Sn as k,Yn as l,w as r,G as x};
